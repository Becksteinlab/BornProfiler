#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
:Author: Kaihsu Tai, Oliver Beckstein
:Year: 2008, 2010
:Licence: GPL
:Copyright: (c) 2008 Kaihsu Tai
:Copyright: (c) 2010 Oliver Beckstein
:URL: http://en.wikiversity.org/wiki/Talk:Poisson%E2%80%93Boltzmann_profile_for_an_ion_channel

I wrote some Python code to automate this process. The job submission
requires a queuing system called Grid Engine. Copyright Â© 2008 Kaihsu
Tai. Moral rights asserted (why?). Hereby licensed under either GFDL
or GNU General Public License at your option.
"""
from __future__ import with_statement

import os
import logging
logger = logging.getLogger('bornprofile') 

usage = """%prog [options] pqr-file samplepoints-file

This script sets up input files for Born energy calculations for
APBS. It expects to find ion positions in the file samplepoints, one
xyz coordinate per line.

The "Born radii" for ions were taken from Table III in

  Alexander A. Rashin, Barry Honig (1985) J. Phys. Chem. 89(26):5588-5593
  http://dx.doi.org/10.1021/j100272a006

This paper suggests using the corrected covalent radius (Born radius)
and not the Pauling radius.
"""

import bornprofiler
from bornprofiler import IONS

JOBSCRIPTS = {
  'local':
"""#!/bin/sh
echo "** %(jobname)s"
echo "-- APBS Born profile job running on $HOSTNAME"
echo "++ apbs %(infile)s > %(outfile)s"
apbs %(infile)s > %(outfile)s
echo "-- job complete: results in %(outfile)s"
""",
  'SBCB':
"""#$ -N %(jobname)s
#$ -S /bin/bash
#$ -l mem_free=500M,mem_total=500M
#$ -cwd
#$ -j y
#$ -r y

echo "APBS Born profile job running on $HOSTNAME"
ulimit -c 64
module load abps/32 
apbs %(infile)s > %(outfile)s

""",
  'darthtater':
"""#$ -N %(jobname)s
#$ -S /bin/bash
#$ -l mem_free=600M
#$ -cwd
#$ -j y
#$ -r y

echo "APBS Born profile job running on $HOSTNAME"
ulimit -c 64
echo "ensuring single threaded calculation"
export OMP_NUM_THREADS=1
/share/apps/APBS/1.3.0/bin/apbs %(infile)s > %(outfile)s

""",
}

APBS_SCRIPT_COMPONENTS = {
  'header': """# APBS input file generated by placeion.py
# for the complex and the ion at z = %(z).3f
""",
  'read':"""
READ
   mol pqr %(protein_pqr)s
   mol pqr %(ion_pqr)s
   mol pqr %(complex_pqr)s
END
""",
  # stage must be one of [cpx,ion,pro]
  'elec':  """
ELEC name %(stage)s
  mg-auto
  mol %(molnum)d
  dime %(DIME_XYZ)s
  cglen %(CGLEN_XYZ)s
  fglen 20 20 20    
  cgcent mol 3
  fgcent mol 2
  # NaCl ionic strength in mol/L
  ion  charge  1   conc %(conc).2f  radius 0.95   # sodium ions
  ion  charge -1   conc %(conc).2f  radius 1.81   # chloride ions
  lpbe
  bcfl mdh
  pdie 2.0 # protein and faux-lipid
  sdie 78.5 # Eisenberg and Crothers Phys. Chem. book 1979
  srfm smol
  chgm spl2
  srad 1.4
  swin 0.3
  sdens 10.0
  temp %(temperature).2f
  calcenergy total
  calcforce no
END
""",
  'printEnergy': """
PRINT elecEnergy %(complex)s - %(ion)s - %(protein)s END
QUIT
""",
}

def apbs_component(name, **kwargs):
  return APBS_SCRIPT_COMPONENTS[name] % kwargs

class Placeion(bornprofiler.BPbase):
  "preparing job for APBS energy profiling by placing ions"

  padding_xy = 40.0
  padding_z  = 80.0
 
  def __init__(self, pqrfile, pointsfile, ionName='Na', ionicStrength=0.15, 
               jobName='bornprofile', script=None, dime=None, temperature=300.0):
    self.pqrName = pqrfile
    self.pointsName = pointsfile
    self.jobName = jobName
    self.ion = IONS[ionName]
    self.ionicStrength = ionicStrength
    self.dime = dime or [97, 97, 193]
    self.temperature = temperature
    self.script = script

    self.cglen = [0, 0, 0]
    self.pqrLines = []

    self.readPQR()
    self.readPoints()

  def generate(self):
    """Generate all input files."""
    self.writePQRs()
    self.writeIn()
    return self.writeJob()

  def readPQR(self):
    with open(self.pqrName, "r") as pqrFile:
      lines = pqrFile.readlines()
      for line in lines:
        if (line[0:4] == "ATOM"):
          self.pqrLines.append(line)
 
    # finding the cglen (coarse grid lengths) automatically
    # This depends on correct spacing in the PQR file.
    minDim = [+100000, +100000, +100000]
    maxDim = [-100000, -100000, -100000]
    for line in lines:
      if (line[0:4] == "ATOM"):
        tokens = line.split()
        for i in range(0, 3):
          if float(tokens[i+5]) < minDim[i]:
            minDim[i] = float(tokens[i+5])
          if float(tokens[i+5]) > maxDim[i]:
            maxDim[i] = float(tokens[i+5])
    for i in [0, 1]:
      self.cglen[i] = (maxDim[i] - minDim[i]) + self.padding_xy
    self.cglen[2] = (maxDim[2] - minDim[2]) + self.padding_z
 
  def writePQRs(self):
    # make directory
    if (not os.path.exists(self.jobName)):
      os.mkdir(self.jobName)
 
    # write protein
    with open(self.jobpath("pro.pqr"), "w") as proFile:
      for line in self.pqrLines:
        proFile.write(line)
 
    # write complex and ion
    for num,point in enumerate(self.points):
      x = point[0]
      y = point[1]
      z = point[2]
      aID = 50000
      rID = 10000
      # born ion is always resname ION
      ionLines = self.getPqrLine(aID, self.ion.atomname, rID, 'ION', x, y, z, self.ion.charge, self.ion.radius)
      # write ion
      with open(self.jobpath(self.filename("ion",num,".pqr")), "w") as ionFile:
        ionFile.write(ionLines)
      # write complex
      with open(self.jobpath(self.filename("cpx",num,".pqr")), "w") as cpxFile:
        for line in self.pqrLines:
          cpxFile.write(line)
        cpxFile.write(ionLines)
    logger.info("[%s] Wrote %d pqr files for protein, ion=%s and complex", 
                self.jobName, num+1, self.ion.atomname)
  
  def writeIn(self):
    for num,point in enumerate(self.points):
      z = point[2]
      with open(self.jobpath(self.infilename(num)), "w") as inFile:
        inFile.write(apbs_component('header', z=z))
        inFile.write(apbs_component('read', protein_pqr="pro.pqr",
                                    ion_pqr=self.filename("ion",num,".pqr"),
                                    complex_pqr=self.filename("cpx",num,".pqr")))
        for count,what in enumerate(["pro", "ion", "cpx"]):
          inFile.write(apbs_component('elec', stage=what, molnum=count+1,
                                      DIME_XYZ=self.get_XYZ_str(self.dime),
                                      CGLEN_XYZ=self.get_XYZ_str(self.cglen),
                                      conc=self.ionicStrength, temperature=self.temperature))
        inFile.write(apbs_component('printEnergy', complex='cpx', ion='ion', protein='pro'))

  def writeJob(self):
    if self.script is None:
      logger.warn("No script template provided; no queuing system scripts are written.")
      return None

    for num,point in enumerate(self.points):
      z = point[2]
      scriptargs = {
        'jobname': "n%04dz%.3f%s"%(num,z,self.jobName),
        'infile': self.infilename(num),
        'outfile': self.outfilename(num),
        }
      with open(self.jobscriptname(num), "w") as jobFile:
        jobFile.write(self.script % scriptargs)
 
    # TODO: template job array script, too
    qsubName = "qsub_" + self.jobName + ".bash"
    with open(qsubName, "w") as jobFile:
      jobFile.write("""#$ -N BP%(jobName)s
#$ -S /bin/bash
#$ -l mem_free=500M,mem_total=500M
#$ -cwd
#$ -j y
#$ -r y
 
declare -a job
 
""" % vars(self))
      for num,point in enumerate(self.points):
        z = point[2]
        jobFile.write('job[%d]="%s"\n' % (num+1, self.jobscriptname(num)))
      jobFile.write("""
run_d=$(dirname ${job[${SGE_TASK_ID}]})
script=$(basename ${job[${SGE_TASK_ID}]})
 
cd ${run_d} || { echo "Failed to cd ${run_d}. Abort."; exit 1; }
. ./${script}
""")
    return num+1
   
if __name__ == "__main__":
  import sys
  from optparse import OptionParser

  logging.basicConfig()

  parser = OptionParser(usage=usage)
  parser.add_option("--name", dest="jobName",
                    metavar="STRING",
                    help="name for the job submission script [%default]")
  parser.add_option("--ion", dest="ionName", type="choice", choices=IONS.keys(),
                    metavar="NAME",
                    help="name of the ion to be sampled. Available values: %r. "
                    "Radii were taken from Table III in Rashin & Honig  1985. "
                    "The default ion is '%%default'." % (IONS.keys(),))
  parser.add_option("--dime", dest="dime", nargs=3, type="int",
                    metavar="NX NY NZ",
                    help="dimensions of the computational grid [97 97 193]")
  parser.add_option("--ionic-strength", dest="ionicStrength", type="float",
                    metavar="CONC",
                    help="set ionic strength of NaCl bath to the given concentration "
                    "CONC in mol/l [%default]")
  parser.add_option("--script", dest="script",
                    metavar="NAME",
                    help="name of a stored script template %r or (advanced usage!) a "
                    "filename that contains appropriate place holders [%%default]" % JOBSCRIPTS.keys())
  parser.set_defaults(ionicStrength=0.15, jobName="bornprofile", 
                      ionName="Na", dime=[97,97,193], script="local")

  opts,args = parser.parse_args()
  
  try:
    pqrfile, pointsfile = args
  except:
    logger.fatal("Needs PQR file and sample points. See --help.")
    sys.exit(1)

  try:
    script_template = JOBSCRIPTS[opts.script]
  except KeyError:
    try:
      script_template = open(opts.script).readlines()
    except:
      logger.fatal("--scripts=NAME must be either a filename or one of %r; see the " 
                   "source for the correct format of the file." % JOBSCRIPTS.keys())
      sys.exit(2)

  P = Placeion(pqrfile, pointsfile, ionName=opts.ionName, ionicStrength=opts.ionicStrength,
               jobName=opts.jobName, script=script_template)
  P.generate()
