#!/usr/bin/python
"""
:Author: Kaihsu Tai
:Year: 2008
:Licence: GPL
:Copyright: (c) 2008 Kaihsu Tai
:URL: http://en.wikiversity.org/wiki/Talk:Poisson%E2%80%93Boltzmann_profile_for_an_ion_channel

I wrote some Python code to automate this process. The job submission requires a queuing system called Grid Engine. Copyright © 2008 Kaihsu Tai. Moral rights asserted (why?). Hereby licensed under either GFDL or GNU General Public License at your option.

Obviously, you will have to change the parameters in the driver-functions (main()) to fit the purposes of this tutorial. That is the exercise for the reader! -- Kaihsu 16:12, 23 December 2008 (UTC)

Also, you will need to generate the PQR file, along with a file containing a list of the coordinates for the sample points. The script submits the job to a queueing system called Grid Engine, but you can submit the job by hand if you do not have this installed. -- Kaihsu 11:04, 9 January 2009 (UTC)

Additionally, you will need to change the ion species. -- Kaihsu 17:03, 30 January 2009 (UTC)

See also Two-dimensional Poisson-Boltzmann profile for an ion channel. -- Kaihsu 13:07, 30 April 2009 (UTC)
"""
import os
 
class placeion:
  "preparing job for APBS energy profiling by placing ions"
 
  def __init__(self):
    self.cglen = [0, 0, 0]
    self.pqrLines = []
 
  def readPQR(self):
    pqrFile = open(self.pqrName, "r")
    lines = pqrFile.readlines()
    for line in lines:
      if (line[0:4] == "ATOM"):
        self.pqrLines.append(line)
    pqrFile.close()
 
    # finding the cglen (coarse grid lengths) automatically
    # This depends on correct spacing in the PQR file.
    minDim = [+100000, +100000, +100000]
    maxDim = [-100000, -100000, -100000]
    for line in lines:
      if (line[0:4] == "ATOM"):
        tokens = line.split()
        for i in range(0, 3):
          if float(tokens[i+5]) < minDim[i]:
            minDim[i] = float(tokens[i+5])
          if float(tokens[i+5]) > maxDim[i]:
            maxDim[i] = float(tokens[i+5])
    for i in [0, 1]:
      self.cglen[i] = (maxDim[i] - minDim[i]) + 40
    self.cglen[2] = (maxDim[2] - minDim[2]) + 80
 
  def writePQRs(self):
    # make directory
    if (not os.path.exists(self.jobName)):
      os.mkdir(self.jobName)
 
    # write protein
    proFile = open(self.jobName + "/pro" + ".pqr", "w")
    for line in self.pqrLines:
      proFile.write(line)
    proFile.close()
 
    # write complex and ion
    for point in self.points:
      x = point[0]
      y = point[1]
      z = point[2]
      aID = 50000
      rID = 10000
      ionLines = ""
      for zOffset in self.zOffsets:
        # example: "ATOM  50000  NHX SPM 10000      43.624  57.177  58.408  1.0000 2.1300"
        ionLines += self.getPqrLine(aID, "NHX", rID, "SPM", x, y, z+zOffset, +1.0, 2.130)
        # entry for NH4(+) in Table III in
        # Rashin and Honig (1985) J. Phys. Chem. 89(26):5588--5593
        # http://dx.doi.org/10.1021/j100272a006
        aID += 1
        rID += 1
 
      # write ion
      ionFile = open(self.jobName + "/ion_" + str(z) + ".pqr", "w")
      ionFile.write(ionLines)
      ionFile.close()
 
      # write complex
      cpxFile = open(self.jobName + "/cpx_" + str(z) + ".pqr", "w")
      for line in self.pqrLines:
        cpxFile.write(line)
      cpxFile.write(ionLines)
      cpxFile.close()
 
  def getPqrLine(self, aID, aType, rID, rType, x, y, z, q, r):
    # example: "ATOM  50000  NHX SPM 10000      43.624  57.177  58.408  1.0000 2.1300"
    line =  "ATOM  "
    line += "%5d  " % aID
    line += "%-4s" % aType
    line += "%3s " % rType
    line += "%5d    " % rID
    line += "%8.3f%8.3f%8.3f " % (x, y, z)
    line += "%7.4f%7.4f\n" % (q, r)
    return line
 
  def readPoints(self):
    pointsFile = open(self.pointsName, "r")
    lines = pointsFile.readlines()
    pointsFile.close()
 
    points = []
    for line in lines:
      tokens = line.split()
      parsed = [float(tokens[0]), float(tokens[1]), float(tokens[2])]
      points.append(parsed)
    self.points = points
 
  def writeIn(self):
    for point in self.points:
      z = point[2]
      inFile = open(self.jobName + "/job_" + str(z) + ".in", "w")
      inFile.write("""# APBS input file generated by """ + __file__ + """
# for the complex and the ion at z = """ + str(z) + "\n") 
 
      inFile.write("""
  read
    mol pqr pro.pqr
    mol pqr ion_""" + str(z) + """.pqr
    mol pqr cpx_""" + str(z) + """.pqr
  end
""")
 
      count = 1
      for what in ["pro", "ion", "cpx"]:
        inFile.write("""
  elec name """ + what + """
    mg-auto
    mol """ + str(count) + """
    dime 97 97 193
    cglen """ + str(self.cglen[0]) + " " + str(self.cglen[1]) + " " + str(self.cglen[2]) + """
    fglen 20 20 20    
    cgcent mol 3
    fgcent mol 2
    # NaCl ionic strength in mol/L
    ion  1 """ + str(self.ionic) + """ 0.95 # sodium ions
    ion -1 """ + str(self.ionic) + """ 1.81 # chloride ions
 
    lpbe
    bcfl mdh
    pdie 2.0 # protein and faux-lipid
    sdie 78.5 # Eisenberg and Crothers Phys. Chem. book 1979
    srfm smol
    chgm spl2
    srad 1.4
    swin 0.3
    sdens 10.0
    temp 300
    # gamma 0.105 # Uncomment for old versions of APBS: deprecated for APBS 1.0.0
    calcenergy total
    calcforce no
  end
""")
        count += 1
 
      inFile.write("""
  print energy cpx - ion - pro end
  quit
""")
      inFile.close()
 
  def writeJob(self):
    for point in self.points:
      z = point[2]
      jobFile = open(self.jobName + "/job_" + str(z) + ".bash", "w")
      jobFile.write("#!/bin/bash\n")
      jobFile.write("""
#$ -N z""" + str(z) + self.jobName + """
#$ -S /bin/bash
#$ -l glibc=2.3,mem_free=500M,mem_total=500M
#$ -cwd
#$ -j y
#$ -r y
echo job running on $HOSTNAME
ulimit -c 64
 
/sansom/fedpacks/bin/apbs """)
      jobFile.write("job_" + str(z) + ".in > job_" + str(z) + ".out")
      jobFile.close()
 
    qsubName = "qsub_" + self.jobName + ".bash"
    jobFile = open(qsubName, "w")
    jobFile.write("""#$ -N """ + self.jobName + """
#$ -S /bin/bash
#$ -l glibc=2.3,mem_free=500M,mem_total=500M
#$ -cwd
#$ -j y
#$ -r y
 
declare -a job
 
""")
    count = 0
    for point in self.points:
      z = point[2]
      jobFile.write("job[" + str(count+1) + ']="' + self.jobName + "/job_" + str(z) + ".bash" + '"\n')
      count += 1
    jobFile.write("""
run_d=$(dirname ${job[${SGE_TASK_ID}]})
script=$(basename ${job[${SGE_TASK_ID}]})
 
cd ${run_d} || { echo "Failed to cd ${run_d}. Abort."; exit 1; }
chmod a+x ${script}
 
exec ./${script}
""")
    jobFile.close()
    return count
 
  def run(self):
    self.readPQR()
    self.readPoints()
    self.writePQRs()
    self.writeIn()
    count = self.writeJob()
    # qsub -t 1-80 qsub_all.sh
    os.spawnl(
      os.P_WAIT, "/sansom/fedpacks/opt/SGE6/bin/lx24-x86/qsub", "/sansom/fedpacks/opt/SGE6/bin/lx24-x86/qsub",
      "-t", "1-" + str(count), "qsub_" + self.jobName + ".bash"
    )
 
def main():
  myP = placeion()
  myP.pqrName = "/sansom/s66/kaihsu/works/oxford/physiome/magnesium/H011.pqr"
  myP.pointsName = "/sansom/s66/kaihsu/works/oxford/physiome/magnesium/samplepoints011.dat"
  myP.ionic = 0.15
 
  # in angstroms
  # set myP.zOffsets to be [-6.3, 0.0, +5.0] for 'butane'  end towards cytoplasm
  # set myP.zOffsets to be [-5.0, 0.0, +6.3] for 'propane' end towards cytoplasm
  myP.zOffsets = [-6.3, 0.0, +5.0] 
  myP.jobName = "H011cytoBut"
 
  myP.run()
 
if __name__ == "__main__":
  main()
